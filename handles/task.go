package handles

import (
	"encoding/xml"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	libutils "github.com/opensourceways/server-common-lib/utils"
	"github.com/robfig/cron/v3"

	"cve-sa-backend/iniconf"
	"cve-sa-backend/utils"
)

const (
	pkgUrl = "http://121.36.84.172/repo.openeuler.org/%s/update_%s/source/Packages/%s"
	size   = 50
)

var num = regexp.MustCompile(`\d`)

func Task(c *cron.Cron) error {
	updateinfoId, err := c.AddFunc("0 0 0 * * 2,4,6", TaskUpdateinfo)
	if err != nil {
		return err
	}
	log.Printf("register updateinfo task %d", updateinfoId)

	return nil
}

func TaskUpdateinfo() {
	log.Println("task updateinfo start")
	cfg, err := iniconf.Cfg.GetSection("cve")
	if err != nil {
		iniconf.SLog.Errorf("get conf failed, err: %s", err.Error())

		return
	}

	uploadDir := iniconf.Obs.UploadDir
	utils.CreateDir(uploadDir)

	var wg sync.WaitGroup

	f := func(b string, fileName string) {
		defer wg.Done()
		var bys []byte
		bys, err = utils.DownloadFile(fmt.Sprintf("updateinfo/%s/updateinfo.xml", b))
		if err != nil {
			iniconf.SLog.Errorf("download %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}
		var v utils.Updates
		err = xml.Unmarshal(bys, &v)
		if err != nil {
			iniconf.SLog.Errorf("xml unmarshal %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}

		l := len(v.Updatex)
		number := l / size
		if l%size != 0 {
			number++
		}

		var w sync.WaitGroup
		ff := func(update []utils.Update, v int) {
			defer w.Done()
			for i := range update {
				u := &update[i]
				res := epochFile(u.Pkglist.Collection.Package, u.Issued.Date, cfg.Key("script").String(), b, v)
				if len(res) == 0 {
					continue
				}
				for j := range u.Pkglist.Collection.Package {
					p := &u.Pkglist.Collection.Package[j]
					if len(p.Epoch) > 0 {
						continue
					}

					p.Epoch = res[strings.Split(p.Filename, "-")[0]]
				}
			}
		}

		for i := 0; i < number; i++ {
			start := i * size
			end := (i + 1) * size
			if end > l {
				end = l
			}
			w.Add(1)
			go ff(v.Updatex[start:end], i)
		}

		w.Wait()

		bys, err = v.UpdatesData()
		if err != nil {
			iniconf.SLog.Errorf("xml marshal %s updateinfo.xml failed, err:%s", b, err.Error())

			return
		}

		if err = os.WriteFile(fileName, bys, os.ModePerm); err == nil {
			err = utils.UploadFile(iniconf.Obs.DownloadUpdateinfo+b+"/updateinfo.xml", fileName)
			if err != nil {
				iniconf.SLog.Errorf("upload file failed, err:%s", err.Error())
			}
			_ = os.Remove(fileName)
		}

		log.Printf("task updateinfo branch:%s end\n", b)
	}

	for _, s := range strings.Split(cfg.Key("branch").String(), ",") {
		wg.Add(1)
		_ = utils.CreateDirAll(filepath.Join(uploadDir, s, "task"))
		log.Printf("start branch: %s\n", s)
		go f(s, filepath.Join(uploadDir, s, "task", "/updateinfo.xml"))
	}

	wg.Wait()

	log.Println("task updateinfo end")
}

func findEpoch(script, branch, date, filename, arch string, i int) ([]byte, error) {
	for _, s := range []string{date, utils.GetLastWeek(date, time.Wednesday)} {
		time.Sleep(time.Microsecond)
		epoch, err, _ := libutils.RunCmd(
			script,
			filepath.Join("/opt/app/", branch, strconv.Itoa(i), time.Now().Format("150405.999999999")+utils.RandStr()),
			fmt.Sprintf(pkgUrl, branch,
				strings.ReplaceAll(s, "-", ""), strings.ReplaceAll(filename, arch, "src")),
		)
		if err == nil {
			return num.Find(epoch), nil
		}
	}

	return nil, nil
}

func epochFile(v []utils.Package, date, script, b string, i int) map[string]string {
	var res = make(map[string]string)
	for _, p := range v {
		if len(p.Epoch) > 0 || strings.Contains(p.Filename, "kernel") {
			continue
		}
		if epoch, err := findEpoch(script, b, date, p.Filename, p.Arch, i); err == nil && len(epoch) > 0 {
			res[strings.Split(p.Filename, "-")[0]] = string(epoch)
		}
		time.Sleep(time.Microsecond)
	}

	return res
}
