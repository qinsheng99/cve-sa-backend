package manage

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"net/http"
	"sort"
	"strings"
	"time"

	"cve-sa-backend/dao"
	. "cve-sa-backend/iniconf"
	"cve-sa-backend/models"
	"cve-sa-backend/utils"
	_const "cve-sa-backend/utils/const"
	"cve-sa-backend/utils/entity/cve_sa"
	"cve-sa-backend/utils/parsexml"

	"gorm.io/gorm"
)

var productType = []string{"aarch64", "noarch", "x86_64"}

func DeleteCVE(cveId, packageName string) (string, error) {
	tx := DB.Begin()
	if packageName == "" {
		//Delete the cve information corresponding to the specified cveId
		delCves, rowsAffected, err := dao.DefaultCveDatabase.GetCveDatabaseByCveIdList(&models.CveDatabase{
			CveId: cveId,
		}, tx)
		if err != nil || rowsAffected == 0 {
			tx.Rollback()
			return "", errors.New("CVE error")
		}
		for _, delCve := range delCves {
			err = DeleteOneCVE(delCve, tx)
			if err != nil {
				tx.Rollback()
				return "", err
			}
		}
		tx.Commit()
		return fmt.Sprintf("Delete CVE %d record.", len(delCves)), nil
	} else {
		delCve, err := dao.DefaultCveDatabase.GetOneDatabase(&models.CveDatabase{
			CveId:       cveId,
			PackageName: packageName,
		}, tx)
		if err != nil {
			tx.Rollback()
			return "", err
		}
		err = DeleteOneCVE(*delCve, tx)
		if err != nil {
			tx.Rollback()
			return "", err
		}
		tx.Commit()
		return "Delete CVE 1 record.", nil
	}
}

func DeleteOneCVE(delCve models.CveDatabase, tx *gorm.DB) error {
	cveCvrf, err := dao.DefaultCvrf.GetOneCvrf(&models.CveCvrf{
		CveId:       delCve.CveId,
		PackageName: delCve.PackageName,
	}, tx)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return err
	}
	if err == nil {
		err = dao.DefaultCvrf.DeleteCvrf(cveCvrf.Id, tx)
		if err != nil {
			return err
		}
	}

	packageList, rowsAffected, err := dao.DefaultCveProductPackage.GetProductPackageList(&models.CveProductPackage{
		CveId:       delCve.CveId,
		PackageName: delCve.PackageName,
	}, tx)
	if err != nil {
		return err
	}
	if rowsAffected > 0 {
		for _, v := range packageList {
			err = dao.DefaultCveProductPackage.DeleteProductPackage(v.Id, tx)
			if err != nil {
				return err
			}
		}
	}

	parserBean, err := dao.DefaultCveParser.GetOneParser(&models.CveParser{
		Cve:         delCve.CveId,
		PackageName: delCve.PackageName,
	}, tx)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return err
	}
	if err == nil {
		err = dao.DefaultCveParser.DeleteParser(parserBean.Id, tx)
		if err != nil {
			return err
		}
	}

	err = dao.DefaultCveDatabase.DeleteCveDatabase(delCve.Id, tx)
	if err != nil {
		return err
	}
	return nil
}

func DeleteSA(saNo string) error {
	var sec *models.CveSecurityNotice
	err := DB.Transaction(func(tx *gorm.DB) error {
		delSecurity, err := dao.DefaultSecurityNotice.GetSecurityNotice(&models.CveSecurityNotice{
			SecurityNoticeNo: saNo,
		}, tx)
		if err != nil {
			return err
		}

		sec = delSecurity

		delPackageList, err := dao.DefaultSecurityNoticePackage.GetPackageList(&models.CveSecurityNoticePackage{
			SecurityNoticeNo: delSecurity.SecurityNoticeNo,
		}, tx)
		if err != nil {
			return err
		}
		if len(delPackageList) > 0 {
			err = dao.DefaultSecurityNoticePackage.DeletePackages(delPackageList, tx)
			if err != nil {
				return err
			}
		}

		delReferenceList, err := dao.DefaultSecurityNoticeReference.GetReferenceList(&models.CveSecurityNoticeReference{
			SecurityNoticeNo: delSecurity.SecurityNoticeNo,
		}, tx)
		if err != nil {
			return err
		}
		if len(delReferenceList) > 0 {
			err = dao.DefaultSecurityNoticeReference.DeleteReferences(delReferenceList, tx)
			if err != nil {
				return err
			}
		}
		cveCvrf, err := dao.DefaultCvrf.GetOneCvrf(&models.CveCvrf{
			SecurityNoticeNo: delSecurity.SecurityNoticeNo,
		}, tx)
		if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			return err
		}
		if err == nil {
			err = dao.DefaultCvrf.DeleteCvrf(cveCvrf.Id, tx)
			if err != nil {
				return err
			}
		}

		err = dao.DefaultSecurityNotice.DeleteSecurityNotice(delSecurity.Id, tx)

		return err
	})
	if err != nil {
		return err
	}

	deleteObsFile(*sec)

	return nil
}

func GetHttpParserBeanListByCve(cve, packageName string) (*models.CveParser, error) {
	return dao.DefaultCveParser.GetOneParserWithDB(&models.CveParser{
		Cve:         cve,
		PackageName: packageName,
	})
}

func SyncCve(cveFileName string) (string, error) {
	fileByte, err := utils.DownloadFile(Obs.DownloadCvrf + cveFileName)
	if err != nil {
		return "SyncCve failed. An exception occurred." + err.Error(), err
	}

	Element := utils.FixedCveXml{}
	err = xml.Unmarshal(fileByte, &Element)
	if err != nil {
		return "SyncCve failed. An exception occurred." + err.Error(), err
	}

	var (
		list     []cvesa.DatabaseData
		vul      []utils.Vulnerability
		cveList  []cvesa.CveIssueUpdate
		isUpload bool
	)
	updateTime := time.Now()
	for k := range Element.Vulnerability {
		v := &Element.Vulnerability[k]
		cve, cErr, sv, flag := parsexml.GetCVEDatabase("", "", "", *v, updateTime)
		if cErr != nil {
			return "SyncCve failed. An exception occurred." + err.Error(), err
		}

		if flag {
			v.CVSSScoreSets.ScoreSet = []utils.ScoreSetChild{
				{BaseScore: strings.Split(sv, "--")[0], Vector: strings.Split(sv, "--")[1]},
			}
			isUpload = true

			cveList = append(cveList, cvesa.CveIssueUpdate{
				CveId:       cve.RCveDatabase.CveDatabase.CveId,
				PackageName: cve.RCveDatabase.CveDatabase.PackageName,
			})
		}
		v.Text = ""
		vul = append(vul, *v)
		list = append(list, cve)
	}
	err = DB.Transaction(func(tx *gorm.DB) error {
		err = SaveAndDeleteCveList(list, tx)
		if err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return "SyncCve failed. An exception occurred." + err.Error(), err
	}

	if isUpload {
		replaceUnaffectedFile(cveFileName, Element, vul, cveList)
	}

	return "CVE sync successfully", nil
}

func replaceUnaffectedFile(cveFileName string, e utils.FixedCveXml, vul []utils.Vulnerability, cveList []cvesa.CveIssueUpdate) {
	bys, err := e.UnaffectdData(vul)
	if err == nil {
		err = utils.UploadFile(Obs.DownloadCvrf+cveFileName, bytes.NewReader(bys))
		if err != nil {
			SLog.Error("obs upload file fail, err: ", err)
		} else if len(cveList) > 0 {
			cBys, _ := json.Marshal(cveList)
			_, err = http.Post("https://api.openeuler.org/cve-manager/v1/cve/issue",
				"application/json", bytes.NewReader(cBys))
			if err != nil {
				SLog.Error(err)
			}
		}
	}
}

func SaveAndDeleteCveList(list []cvesa.DatabaseData, tx *gorm.DB) error {
	for _, v := range list {
		err := dao.DefaultCvrf.DeleteByCveIdAndPackageName(v.Cvrf.CveId, v.Cvrf.PackageName, tx)
		if err != nil {
			return err
		}
		err = dao.DefaultCvrf.InsertCvrf(&v.Cvrf.CveCvrf, tx)
		if err != nil {
			return err
		}
		status := 0
		for _, pk := range v.PackageList {
			var p = models.CveProductPackage{CveId: pk.CveId, ProductName: pk.ProductName, PackageName: pk.PackageName}
			lists, _, _ := dao.DefaultCveProductPackage.GetProductPackageList(&p, tx)
			if len(lists) <= 0 {
				err = dao.DefaultCveProductPackage.InsertProductPackage(&pk.CveProductPackage, tx)
				if err != nil {
					return err
				}
			} else {
				pk.CveProductPackage.Id = lists[0].Id
				err = dao.DefaultCveProductPackage.UpdateProductPackage(&pk.CveProductPackage, tx)
				if err != nil {
					return err
				}
			}

			if strings.EqualFold(pk.CveProductPackage.Status, "Fixed") {
				status = 1
			}
			if status != 1 {
				if strings.EqualFold(pk.CveProductPackage.Status, "Unaffected") {
					status = 2
				}
			}
		}
		cvedata := &v.RCveDatabase.CveDatabase

		result, rowsAffected, _ := dao.DefaultCveProductPackage.GetProductPackageListTypeTwo(&models.CveProductPackage{
			CveId:       v.RCveDatabase.CveId,
			PackageName: v.RCveDatabase.PackageName,
		})
		if rowsAffected > 0 {
			for _, zv := range result {
				if strings.EqualFold(zv.Status, "Fixed") {
					status = 1
					break
				}
			}
		}

		if status == 1 {
			cvedata.Status = "Fixed"
		}
		if status == 2 {
			cvedata.Status = "Unaffected"
		}

		err = dao.DefaultCveParser.DeleteByCveAndPackageName(v.ParserBean.CveParser.Cve, v.ParserBean.CveParser.PackageName, tx)
		if err != nil {
			return err
		}
		err = dao.DefaultCveParser.InsertParser(&v.ParserBean.CveParser, tx)
		if err != nil {
			return err
		}

		cved, err := dao.DefaultCveDatabase.GetOneDatabaseTypeTwo(&models.CveDatabase{
			CveId:       cvedata.CveId,
			PackageName: cvedata.PackageName,
		})

		if err == nil {
			err = dao.DefaultCveDatabase.UpdateCve(cvedata, tx, cved.Id)
			if err != nil {
				return err
			}
		} else if utils.ErrorNotFound(err) {
			err = dao.DefaultCveDatabase.InsertCveDatabase(cvedata, tx)
			if err != nil {
				return err
			}
		} else {
			return err
		}

	}

	return nil
}

func SyncHardwareCompatibility() (string, error) {
	var listZh, listEn []*cvesa.HardwareCompatibility
	var err error
	defer dao.DefaultCompatibilityHardware.UpdateIsDelete(0)
	err = dao.DefaultCompatibilityHardware.UpdateIsDelete(1)
	if err != nil {
		return "", err
	}
	listZh, err = parserHardwareCompatibility("zh")
	if err != nil {
		return fmt.Sprint("获取数据失败:"), err
	}
	listEn, err = parserHardwareCompatibility("en")
	if err != nil {
		return fmt.Sprint("获取数据失败:"), err
	}
	err = DB.Transaction(func(tx *gorm.DB) error {
		if listZh != nil && len(listZh) > 0 {
			assemblyHardware(listZh, "zh")
			err = saveList(listZh, tx)
			if err != nil {
				return err
			}
		}

		if listEn != nil && len(listEn) > 0 {
			assemblyHardware(listEn, "en")
			err = saveList(listEn, tx)
			if err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	err = dao.DefaultCompatibilityHardware.Delete()
	if err != nil {
		return "", err
	}
	return "success", nil
}

// parserHardwareCompatibility Request zh or en json data, and json unmarshal cveSa.HardwareCompatibility
func parserHardwareCompatibility(lang string) ([]*cvesa.HardwareCompatibility, error) {
	var bytes []byte
	var err error
	switch lang {
	case "zh":
		bytes, err = utils.HTTPGet(_const.ParserHardwareFileZh)
		if err != nil {
			return nil, err
		}
	case "en":
		bytes, err = utils.HTTPGet(_const.ParserHardwareFileEn)
		if err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("the input parameter `lang` must be zh or en")
	}
	if strings.Index(string(bytes), "<!DOCTYPE html>") > -1 || strings.Index(string(bytes), "<html>") > -1 {
		return nil, nil
	}
	var datas []*cvesa.HardwareCompatibility
	err = json.Unmarshal(bytes, &datas)
	if err != nil {
		return nil, err
	}
	return datas, nil
}

// assemblyHardware assembly oe_compatibility_hardware insert datas
func assemblyHardware(datas []*cvesa.HardwareCompatibility, lang string) {
	timeStr := utils.GetCurTime()
	for k := range datas {
		data := datas[k]
		if data.CompatibilityConfiguration == nil {
			continue
		}
		data.OeCompatibilityHardware.ProductInformation = data.CompatibilityConfiguration.ProductInformation
		data.OeCompatibilityHardware.CertificationTime = data.CompatibilityConfiguration.CertificationTime
		data.OeCompatibilityHardware.CommitID = data.CompatibilityConfiguration.CommitID
		data.OeCompatibilityHardware.MotherBoardRevision = data.CompatibilityConfiguration.MotherBoardRevision
		data.OeCompatibilityHardware.BiosUefi = data.CompatibilityConfiguration.BiosUefi
		data.OeCompatibilityHardware.Cpu = data.CompatibilityConfiguration.Cpu
		data.OeCompatibilityHardware.Ram = data.CompatibilityConfiguration.Ram
		data.OeCompatibilityHardware.PortsBusTypes = data.CompatibilityConfiguration.PortsBusTypes
		data.OeCompatibilityHardware.VideoAdapter = data.CompatibilityConfiguration.VideoAdapter
		data.OeCompatibilityHardware.HostBusAdapter = data.CompatibilityConfiguration.HostBusAdapter
		data.OeCompatibilityHardware.HardDiskDrive = data.CompatibilityConfiguration.HardDiskDrive
		data.OeCompatibilityHardware.Updateime = timeStr
		data.OeCompatibilityHardware.Lang = lang
	}
}
func saveList(datas []*cvesa.HardwareCompatibility, tx *gorm.DB) error {
	for k := range datas {
		hardware := datas[k]
		list := hardware.OeCompatibilityHardware
		var data = &models.OeCompatibilityHardware{
			HardwareFactory: list.HardwareFactory,
			HardwareModel:   list.HardwareModel,
			OsVersion:       list.OsVersion,
			Lang:            list.Lang,
		}
		list.Isdelete = dao.DefaultCompatibilityHardware.Isdelete(0)
		err := dao.DefaultCompatibilityHardware.FindHardwareOne(data, tx)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				err = dao.DefaultCompatibilityHardware.CreateHardware(&list, tx)
				if err != nil {
					return err
				}
			} else {
				return err
			}
		} else {
			list.Id = data.Id
			err = dao.DefaultCompatibilityHardware.UpdateHardware(&list, tx)
			if err != nil {
				return err
			}
		}
		err = dao.DefaultCompatibilityHardwareAdapter.Delete(list.Id, tx)
		if err != nil {
			return err
		}
		for kk := range hardware.BoardCards {
			adapter := hardware.BoardCards[kk]
			adapter.HardwareId = list.Id
			adapter.Lang = list.Lang
			adapter.Updateime = list.Updateime
			err = dao.DefaultCompatibilityHardwareAdapter.CreateAdapter(adapter, tx)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func SyncDriverCompatibility() (string, error) {
	var listZh, listEn []models.OeCompatibilityDriverResponse
	var err error
	listZh, err = parserOEDriverCompatibility("zh")
	if err != nil {
		return fmt.Sprint("获取数据失败:"), err
	}
	listEn, err = parserOEDriverCompatibility("en")
	if err != nil {
		return fmt.Sprint("获取数据失败:"), err
	}
	err = DB.Transaction(func(tx *gorm.DB) error {
		if listZh != nil && len(listZh) > 0 {
			err = dao.DefaultCompatibilityDriver.DeleteDriverForLang("zh", tx)
			if err != nil {
				return err
			}
			drivers := assemblyDriver(listZh, "zh")
			err = dao.DefaultCompatibilityDriver.CreateDriver(drivers, tx)
			if err != nil {
				return err
			}
		}
		if listEn != nil && len(listEn) > 0 {
			err = dao.DefaultCompatibilityDriver.DeleteDriverForLang("en", tx)
			if err != nil {
				return err
			}
			drivers := assemblyDriver(listEn, "en")
			err = dao.DefaultCompatibilityDriver.CreateDriver(drivers, tx)
			if err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	return "success", nil
}

func parserOEDriverCompatibility(lang string) ([]models.OeCompatibilityDriverResponse, error) {
	var bytes []byte
	var err error
	switch lang {
	case "zh":
		bytes, err = utils.HTTPGet(_const.ParserDriverFileZh)
		if err != nil {
			return nil, err
		}
	case "en":
		bytes, err = utils.HTTPGet(_const.ParserDriverFileEn)
		if err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("the input parameter `lang` must be zh or en")
	}
	if strings.Index(string(bytes), "<!DOCTYPE html>") > -1 {
		return nil, nil
	}
	var datas []models.OeCompatibilityDriverResponse
	err = json.Unmarshal(bytes, &datas)
	if err != nil {
		return nil, err
	}
	return datas, nil
}

func assemblyDriver(datas []models.OeCompatibilityDriverResponse, lang string) []models.OeCompatibilityDriver {
	var list = make([]models.OeCompatibilityDriver, 0, len(datas))
	timeStr := utils.GetCurTime()
	for _, v := range datas {
		list = append(list, joinDriver(v, timeStr, lang))
	}
	return list
}

func joinDriver(data models.OeCompatibilityDriverResponse, timeStr, lang string) models.OeCompatibilityDriver {
	return models.OeCompatibilityDriver{
		Architecture: data.Architecture,
		BoardModel:   data.BoardModel,
		ChipModel:    utils.InterfaceToString(data.ChipModel),
		ChipVendor:   data.ChipVendor,
		Deviceid:     utils.InterfaceToString(data.Deviceid),
		DownloadLink: data.DownloadLink,
		DriverDate:   data.DriverDate,
		DriverName:   data.DriverName,
		DriverSize:   data.DriverSize,
		Item:         data.Item,
		Os:           data.Os,
		Sha256:       data.Sha256,
		SsID:         utils.InterfaceToString(data.SsID),
		SvID:         utils.InterfaceToString(data.SvID),
		Type:         data.Type,
		Vendorid:     utils.InterfaceToString(data.Vendorid),
		Version:      data.Version,
		Lang:         lang,
		Updateime:    timeStr,
	}
}

func TransferData(cve string) (string, error) {
	tx := DB.Begin()
	switch cve {
	case "SAreference":
		list, err := dao.DefaultSecurityNotice.FindAllSecurityNotice()
		if err != nil {
			return "", err
		}
		var insert = make([]models.CveSecurityNoticeReference, 0)
		for _, v := range list {
			if v.ReferenceDocuments != "" {
				arr := strings.Split(v.ReferenceDocuments, "\n")
				for _, s := range arr {
					insert = append(insert, models.CveSecurityNoticeReference{
						SecurityNoticeNo: v.SecurityNoticeNo,
						Type:             _const.TypeOther,
						Url:              s,
						Updateime:        v.Updateime,
					})
				}
			}
		}
		if len(insert) > 0 {
			err = dao.DefaultSecurityNoticeReference.CreateReference(insert, tx)
			if err != nil {
				tx.Rollback()
				return "", err
			}
			tx.Commit()
		}
	case "CVEstatus":
		list, err := dao.DefaultCveDatabase.FindAllCveDatabase()
		if err != nil {
			return "", err
		}
		for _, v := range list {
			packageList, total, err := dao.DefaultCveProductPackage.GetProductPackageList(&models.CveProductPackage{
				CveId:       v.CveId,
				PackageName: v.PackageName,
			}, DB)
			if err != nil {
				return "", err
			}
			var status = ""

			if total > 0 {
				for _, pl := range packageList {
					if strings.EqualFold(pl.Status, "Fixed") {
						status = "Fixed"
					} else if strings.EqualFold(pl.Status, "Unaffected") {
						//if status is not Fixed,the status is Unaffected
						if status != "Fixed" {
							status = "Unaffected"
						}
					}
				}
			}
			v.Status = status
			err = dao.DefaultCveDatabase.UpdateCve(v, tx, v.Id)
			if err != nil {
				tx.Rollback()
				return "", err
			}
		}
		tx.Commit()
	case "SApackage":
		list, err := dao.DefaultSecurityNotice.FindAllSecurityNotice()
		if err != nil {
			return "", err
		}
		var insert = make([]models.CveSecurityNoticePackage, 0, len(list))
		var srcInsert = make([]models.CveSecurityNoticePackage, 0, len(list))
		var aarIsert = make([]models.CveSecurityNoticePackage, 0, len(list))
		var x86insert = make([]models.CveSecurityNoticePackage, 0, len(list))

		for _, v := range list {
			if v.PackageName != "" {
				arr := strings.Split(v.PackageName, ";")
				for _, s := range arr {
					if s == "" || len(s) < 3 {
						continue
					}
					snr := models.CveSecurityNoticePackage{}
					snr.SecurityNoticeNo = v.SecurityNoticeNo
					snr.PackageType = getPackageType(s)
					snr.ProductName = v.AffectedProduct
					snr.PackageName = utils.TrimStringNR(s)
					snr.Updateime = v.Updateime

					if snr.PackageType == "src" {
						srcInsert = append(srcInsert, snr)
					} else if snr.PackageType == "noarch" {
						aarch64 := snr
						aarch64.PackageType = "aarch64"
						aarch64.PackageName = utils.TrimStringNR(s)
						aarIsert = append(aarIsert, aarch64)

						x86 := snr
						x86.PackageType = "x86_64"
						x86.PackageName = utils.TrimStringNR(s)
						x86insert = append(x86insert, x86)
					} else if snr.PackageType == "aarch64" {
						aarIsert = append(aarIsert, snr)
					} else if snr.PackageType == "x86_64" {
						x86insert = append(x86insert, snr)
					}
				}
				insert = append(insert, srcInsert...)
				insert = append(insert, aarIsert...)
				insert = append(insert, x86insert...)
			}
		}
		err = dao.DefaultSecurityNoticePackage.CreatePackage(insert, tx)
		if err != nil {
			tx.Rollback()
			return "", err
		}
		tx.Commit()
	default:
		return "Parameter error", nil
	}
	return "success", nil
}
func getPackageType(s string) string {
	if strings.Contains(s, ".src.rpm") {
		return "src"
	} else if strings.Contains(s, "aarch64.rpm") {
		return "aarch64"
	} else if strings.Contains(s, "x86_64.rpm") {
		return "x86_64"
	} else if strings.Contains(s, "noarch.rpm") {
		return "noarch"
	} else {
		return ""
	}
}

func SyncSA(saFileName string) (string, error) {
	security, err := ParserSA(saFileName)
	if err != nil {
		return "SyncSA failed. SAfile : " + saFileName + " parser exception occurred. error message:" + err.Error(), err
	}
	var delSecurity *models.CveSecurityNotice
	err = DB.Transaction(func(tx *gorm.DB) error {
		delSecurity, err = dao.DefaultSecurityNotice.GetOneSecurity(&models.CveSecurityNotice{SecurityNoticeNo: security.SecurityNoticeNo}, tx)
		if err != nil {
			return err
		}
		if delSecurity != nil {
			err = dao.DefaultSecurityNotice.DeleteSecurity(delSecurity.Id, tx)
			if err != nil {
				return err
			}
		}
		err = dao.DefaultSecurityNotice.CreateSecurity(security.RCveSecurityNotice.CveSecurityNotice, tx)
		if err != nil {
			return err
		}

		var delPackageList []models.CveSecurityNoticePackage
		delPackageList, err = dao.DefaultSecurityNoticePackage.GetPackageList(&models.CveSecurityNoticePackage{SecurityNoticeNo: security.SecurityNoticeNo}, tx)
		if err != nil {
			return err
		}
		if len(delPackageList) > 0 {
			err = dao.DefaultSecurityNoticePackage.DeletePackages(delPackageList, tx)
			if err != nil {
				return err
			}
		}

		if security.PackageList != nil && len(security.PackageList) > 0 {
			var insert = make([]models.CveSecurityNoticePackage, 0, len(security.PackageList))
			var srcInsert = make([]models.CveSecurityNoticePackage, 0, len(security.PackageList))
			var aarIsert = make([]models.CveSecurityNoticePackage, 0, len(security.PackageList))
			var x86insert = make([]models.CveSecurityNoticePackage, 0, len(security.PackageList))

			for _, v := range security.PackageList {
				if v.CveSecurityNoticePackage.PackageType == "src" {
					srcInsert = append(srcInsert, v.CveSecurityNoticePackage)
				} else if v.CveSecurityNoticePackage.PackageType == "noarch" {
					aarIsert = append(aarIsert, v.CveSecurityNoticePackage)
				} else if v.CveSecurityNoticePackage.PackageType == "aarch64" {
					aarIsert = append(aarIsert, v.CveSecurityNoticePackage)
				} else if v.CveSecurityNoticePackage.PackageType == "x86_64" {
					x86insert = append(x86insert, v.CveSecurityNoticePackage)
				}
			}
			insert = append(insert, srcInsert...)
			insert = append(insert, aarIsert...)
			insert = append(insert, x86insert...)
			err = dao.DefaultSecurityNoticePackage.CreatePackage(insert, tx)
			if err != nil {
				return err
			}
		}

		var delReferenceList []models.CveSecurityNoticeReference
		delReferenceList, err = dao.DefaultSecurityNoticeReference.GetReferenceList(&models.CveSecurityNoticeReference{SecurityNoticeNo: security.SecurityNoticeNo}, tx)
		if err != nil {
			return err
		}
		if len(delReferenceList) > 0 {
			err = dao.DefaultSecurityNoticeReference.DeleteReferences(delReferenceList, tx)
			if err != nil {
				return err
			}
		}

		if security.ReferenceList != nil && len(security.ReferenceList) > 0 {
			var i = make([]models.CveSecurityNoticeReference, 0, len(security.ReferenceList))
			for _, v := range security.ReferenceList {
				i = append(i, v.CveSecurityNoticeReference)
			}
			err = dao.DefaultSecurityNoticeReference.CreateReference(i, tx)
			if err != nil {
				return err
			}
		}

		var delCvrf = new(models.CveCvrf)
		delCvrf, err = dao.DefaultCvrf.GetOneCvrf(&models.CveCvrf{SecurityNoticeNo: security.SecurityNoticeNo}, tx)
		if err != nil && !utils.ErrorNotFound(err) {
			return err
		}
		if delCvrf.Id > 0 {
			err = dao.DefaultCvrf.DeleteCvrf(delCvrf.Id, tx)
			if err != nil {
				return err
			}
		}

		if security.Cvrf != nil {
			err = dao.DefaultCvrf.InsertCvrf(&security.Cvrf.CveCvrf, tx)
			if err != nil {
				return err
			}
		}
		if len(security.CveList) > 0 {
			err = SaveAndDeleteCveList(security.CveList, tx)
			if err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return "SyncSA failed. database exception occurred. error message:" + err.Error(), err
	}

	uploadObsFile(security.RCveSecurityNotice.CveSecurityNotice)

	return "SA sync successfully", nil
}

// deleteObsFile  delete updateinfo.xml and hotpatch.xml
func deleteObsFile(security models.CveSecurityNotice) {
	downloadDir := Obs.DownloadUpdateinfo

	for _, branch := range strings.Split(security.AffectedProduct, ";") {
		var u utils.Updates
		if bys, err := utils.DownloadFile(downloadDir + branch + "/updateinfo.xml"); err == nil {
			if err = xml.Unmarshal(bys, &u); err != nil {
				SLog.Error(err)
				continue
			}
		}

		var patch utils.HotPatchs
		if bys, err := utils.DownloadFile("hotpatch/" + branch + "/updateinfo.xml"); err == nil {
			if err = xml.Unmarshal(bys, &patch); err != nil {
				SLog.Error(err)
				continue
			}
		}

		if i := u.NumberIndex(security.SecurityNoticeNo); i >= 0 {
			if i == 0 {
				u.Updatex = u.Updatex[1:]
			} else if i == len(u.Updatex)-1 {
				u.Updatex = u.Updatex[:i]
			} else {
				u.Updatex = append(u.Updatex[:i], u.Updatex[i+1:]...)
			}

			sort.Slice(u.Updatex, func(i, j int) bool {
				return u.Updatex[i].Id < u.Updatex[j].Id
			})

			if err := upload(u, downloadDir+branch+"/updateinfo.xml"); err != nil {
				SLog.Error(err)
				continue
			}
		}

		if i := patch.NumberIndex(security.SecurityNoticeNo); i >= 0 {
			if i == 0 {
				patch.Updatex = patch.Updatex[1:]
			} else if i == len(u.Updatex)-1 {
				patch.Updatex = patch.Updatex[:i]
			} else {
				patch.Updatex = append(patch.Updatex[:i], patch.Updatex[i+1:]...)
			}

			sort.Slice(patch.Updatex, func(i, j int) bool {
				return patch.Updatex[i].Id < patch.Updatex[j].Id
			})

			if err := upload(patch, "hotpatch/"+branch+"/updateinfo.xml"); err != nil {
				SLog.Error(err)
				continue
			}
		}
	}
}

func upload(u utils.Data, key string) error {
	bys, err := u.UpdatesData()
	if err != nil {
		return err
	}

	err = utils.UploadFile(key, bytes.NewReader(bys))

	return err
}

// uploadObsFile upload updateinfo.xml and hotpatch.xml
func uploadObsFile(security models.CveSecurityNotice) {
	downloadDir := Obs.DownloadUpdateinfo

	for _, branch := range strings.Split(security.AffectedProduct, ";") {
		var u utils.Updates
		if bys, err := utils.DownloadFile(downloadDir + branch + "/updateinfo.xml"); err == nil {
			if err = xml.Unmarshal(bys, &u); err != nil {
				SLog.Error("xml unmarshal updateinfo file failed, err:", err)
				continue
			}
		}

		var patch utils.HotPatchs

		if bys, err := utils.DownloadFile("hotpatch/" + branch + "/updateinfo.xml"); err == nil {
			if err = xml.Unmarshal(bys, &patch); err != nil {
				SLog.Error("xml unmarshal hotpatch file failed, err:", err)
				continue
			}
		}

		up, patchfile := updatesXml(security, branch)

		if i := u.NumberIndex(security.SecurityNoticeNo); i == -1 {
			u.Updatex = append(u.Updatex, up)
		} else {
			u.Updatex[i] = up
		}

		if len(patchfile.Pkglist.Collection.Package) != 0 {
			if i := patch.NumberIndex(security.SecurityNoticeNo); i == -1 {
				patch.Updatex = append(patch.Updatex, patchfile)
			} else {
				patch.Updatex[i] = patchfile
			}
		}

		sort.Slice(u.Updatex, func(i, j int) bool {
			return u.Updatex[i].Id < u.Updatex[j].Id
		})

		sort.Slice(patch.Updatex, func(i, j int) bool {
			return patch.Updatex[i].Id < patch.Updatex[j].Id
		})

		if err := upload(u, downloadDir+branch+"/updateinfo.xml"); err != nil {
			SLog.Error(err)
			continue
		}

		if err := upload(patch, "hotpatch/"+branch+"/updateinfo.xml"); err != nil {
			SLog.Error(err)
			continue
		}
	}
}

// generate updateinfo.xml and hotpatch.xml
func updatesXml(security models.CveSecurityNotice, branch string) (up utils.Update, hotpatch utils.HotPatch) {
	var title, descr string
	if i := strings.Index(security.Introduction, "openEuler"); i > 0 {
		title = security.Introduction[:i] + branch
	}

	if i := strings.Index(security.Description, "Security Fix(es):"); i > 0 {
		descr = utils.TrimStringNR(security.Description[i+17:])
	}

	up = utils.Update{
		From: "openeuler.org", Type: "security",
		Status: "stable", Id: security.SecurityNoticeNo,
		Title: title, Severity: utils.Severity[strings.ToLower(security.Type)],
		Release: "openEuler", Issued: &utils.Issued{Date: security.AnnouncementTime},
		Description: descr,
	}

	var ref []utils.Reference
	for _, s := range strings.Split(security.CveId, ";") {
		if s != "" {
			ref = append(ref, utils.Reference{Href: _const.URL + s, Id: s, Title: s, Type: "cve"})
		}
	}

	up.References = &utils.References{Reference: ref}

	hotpatch = utils.HotPatch{
		From: up.From, Type: up.Type,
		Status: up.Status, Id: security.SecurityNoticeNo,
		Title: title, Severity: up.Severity,
		Release: up.Release, Issued: up.Issued,
		References: up.References, Description: descr,
	}

	var pack []utils.Package
	for _, s := range productType {
		l, _ := dao.DefaultSecurityNoticePackage.PackageList(
			models.CveSecurityNoticePackage{
				SecurityNoticeNo: security.SecurityNoticeNo, ProductName: branch, PackageType: s, Type: "cold_patch",
			},
		)

		for _, p := range l {
			var pe = utils.Package{Filename: p.PackageName}
			if packVersionList := strings.Split(p.PackageName, "-"); len(packVersionList) >= 3 {
				pe.Version = packVersionList[len(packVersionList)-2]
				rpmName := packVersionList[len(packVersionList)-1][:len(packVersionList[len(packVersionList)-1])-4]
				if lastIndex := strings.LastIndexAny(rpmName, "."); lastIndex != -1 {
					pe.Release = rpmName[:lastIndex]
					pe.Arch = rpmName[lastIndex+1:]
				}
				pe.Name = strings.Join(packVersionList[0:len(packVersionList)-2], "-")
			}
			pack = append(pack, pe)
		}
	}

	up.Pkglist = &utils.Pkglist{Collection: &utils.Collection{Name: "openEuler", Package: pack}}

	var hotpatchPack = make([]utils.Package, 0)

	for _, s := range productType {
		p, _ := dao.DefaultSecurityNoticePackage.PackageList(
			models.CveSecurityNoticePackage{
				SecurityNoticeNo: security.SecurityNoticeNo, ProductName: branch, PackageType: s, Type: "hot_patch",
			},
		)

		for i := range p {
			var pe = utils.Package{Filename: p[i].PackageName, Id: p[i].CveNum, Arch: s, Release: "1", Version: "1"}

			if x := strings.Index(p[i].PackageName, s+".rpm"); x >= 1 {
				pe.Name = p[i].PackageName[:x-1]
			}

			if x := utils.FindHotpatchPackage(hotpatchPack, pe.Filename, pe.Arch); x == -1 {
				hotpatchPack = append(hotpatchPack, pe)
			} else {
				if !strings.Contains(hotpatchPack[x].Id, pe.Id) {
					hotpatchPack[x].Id = hotpatchPack[x].Id + "," + pe.Id
				}
			}
		}
	}

	hotpatch.Pkglist = &utils.HotPatchlist{Collection: &utils.PatchCollection{Name: "openEuler", Package: hotpatchPack}}

	return
}

func ParserSA(url string) (*cvesa.SecurityNoticeData, error) {
	var security = new(cvesa.SecurityNoticeData)
	var cveList = make([]cvesa.DatabaseData, 0)
	now := time.Now()
	s, err := utils.DownloadFile(Obs.DownloadCvrf + url)
	if err != nil {
		return nil, err
	}

	var element utils.FixedCveXml
	err = xml.Unmarshal(s, &element)
	if err != nil {
		return nil, err
	}

	err = setRevisionHistory(security, element.DocumentTracking)
	if err != nil {
		return nil, err
	}
	setSecurity(security, element.DocumentNotes)
	setReference(security, element.DocumentReferences, now)
	setProduct(security, element.ProductTree, element.HotPatchTree, now)
	for _, v := range element.Vulnerability {
		cve, err, _, _ := parsexml.GetCVEDatabase(security.SecurityNoticeNo, security.AffectedComponent, security.AnnouncementTime, v, now)
		if err != nil {
			return nil, err
		}
		cveList = append(cveList, cve)
	}
	security.RCveSecurityNotice.CveSecurityNotice.Updateime = now
	security.CveList = cveList

	cvrf := new(models.RCveCvrf)
	cvrf.Cvrf = string(s)
	cvrf.SecurityNoticeNo = security.SecurityNoticeNo
	cvrf.CveCvrf.Updateime = now
	security.Cvrf = cvrf
	return security, nil
}

func setRevisionHistory(security *cvesa.SecurityNoticeData, child utils.DocumentTracking) error {
	security.SecurityNoticeNo = child.Identification.ID
	var listm = make([]map[string]string, 0)
	for _, v := range child.RevisionHistory.Revision {
		var m = make(map[string]string)
		m["Number"] = v.Number
		m["Date"] = v.Date
		m["Description"] = v.Description
		listm = append(listm, m)
	}
	bys, err := json.Marshal(&listm)
	if err != nil {
		return err
	}
	security.RevisionHistory = string(bys)
	security.AnnouncementTime = child.InitialReleaseDate
	return nil
}

func setSecurity(security *cvesa.SecurityNoticeData, child utils.DocumentNotes) {
	for _, v := range child.Note {
		if v.Title == _const.Synopsis {
			security.Summary = v.Note
		}
		if v.Title == _const.Summary {
			security.Introduction = v.Note
		}
		if v.Title == _const.Description {
			security.Description = utils.XmlSpecCharHand(v.Note)
		}
		if v.Title == _const.Topic {
			security.Subject = utils.XmlSpecCharHand(v.Note)
		}
		if v.Title == _const.Severity {
			security.Type = v.Note
		}
		if v.Title == _const.AffectedComponent {
			security.AffectedComponent = v.Note
		}
	}
}

func setReference(security *cvesa.SecurityNoticeData, child utils.DocumentReferences, time time.Time) {
	var referenceList = make([]models.RCveSecurityNoticeReference, 0)
	var cveId = ""
	for _, v := range child.Reference {
		ty := v.Type
		for _, vv := range v.URL {
			snr := models.RCveSecurityNoticeReference{}
			snr.SecurityNoticeNo = security.SecurityNoticeNo
			snr.Type = ty
			snr.Url = vv
			snr.CveSecurityNoticeReference.Updateime = time
			referenceList = append(referenceList, snr)

			if ty == _const.OpenEulerCVE {
				start := strings.Index(vv, "CVE-")
				if start > -1 && len(v.URL) > 0 {
					cveId += vv[start:] + ";"
				}
			}
		}
	}
	security.CveId = cveId
	security.ReferenceList = referenceList
}

func setProduct(security *cvesa.SecurityNoticeData, child utils.ProductTree, patch utils.HotPatchTree, time time.Time) {
	var packageList = make([]models.RCveSecurityNoticePackage, 0)
	var productName = ""
	var cpeProductMap = make(map[string]string, 8)
	for _, v := range child.Branch {
		name := v.Name
		if name == _const.OpenEuler {
			for _, full := range v.FullProductName {
				cpeProductMap[full.CPE] = full.ProductID
				productName += full.ProductName + ";"
			}
		} else {
			for _, full := range v.FullProductName {
				snp := models.RCveSecurityNoticePackage{}
				snp.SecurityNoticeNo = security.SecurityNoticeNo
				snp.Type = "cold_patch"
				snp.PackageName = full.ProductName
				snp.PackageType = name
				snp.ProductName = getOrDefault(cpeProductMap, full.CPE, "")
				snp.CveSecurityNoticePackage.Updateime = time
				packageList = append(packageList, snp)
			}
		}
	}

	for _, v := range patch.Branch {
		if v.Name != _const.OpenEuler {
			for _, full := range v.FullProductName {
				snp := models.RCveSecurityNoticePackage{}
				snp.CveNum = full.CVE
				snp.Type = "hot_patch"
				snp.PackageName = full.ProductName
				snp.ProductName = getOrDefault(cpeProductMap, full.CPE, "")
				snp.PackageType = v.Name
				snp.SecurityNoticeNo = security.SecurityNoticeNo
				snp.CveSecurityNoticePackage.Updateime = time
				packageList = append(packageList, snp)
			}
		}
	}
	if len(productName) > 1 {
		productName = productName[0 : len(productName)-1]
	}
	security.AffectedProduct = productName
	security.PackageList = packageList
}

func getOrDefault(m map[string]string, key, defaultV string) string {
	if value, ok := m[key]; ok {
		return value
	}
	return defaultV
}

func rSyncAll() string {
	return "SyncAll failed. An exception occurred."
}
func SyncAll() (string, error) {
	var result string
	var err error
	unaffect, err := utils.DownloadFile(Obs.DownloadCvrf + _const.UpdateUnaddect)
	if err != nil {
		return rSyncAll(), err
	}
	cvrfFileUnaffect := string(unaffect)

	fixed, err := utils.DownloadFile(Obs.DownloadCvrf + _const.UpdateFixed)
	if err != nil {
		return rSyncAll(), err
	}
	cvrfFileFixed := string(fixed)

	tx := DB
	cveSync, err := dao.DefaultCvrfSync.GetSyncOne(&models.CveCvrfSync{Type: _const.UpdateUnaddect}, tx)
	if err != nil {
		return rSyncAll(), err
	}
	saSync, err := dao.DefaultCvrfSync.GetSyncOne(&models.CveCvrfSync{Type: _const.UpdateFixed}, tx)
	if err != nil {
		return rSyncAll(), err
	}

	if cveSync == nil || cveSync.CvrfFile != cvrfFileUnaffect {
		if cveSync == nil {
			cveSync = new(models.CveCvrfSync)
		}
		if cvrfFileUnaffect != "" && strings.HasSuffix(cvrfFileUnaffect, ".xml") {
			result, err = SyncCve(cvrfFileUnaffect)
			if err != nil {
				return rSyncAll(), err
			}
		}
		cveSync.CvrfFile = cvrfFileUnaffect
		cveSync.Type = _const.UpdateUnaddect
		cveSync.Updateime = time.Now()
		if strings.Index(result, "successfully") > -1 {
			err = dao.DefaultCvrfSync.CreateSyncOne(cveSync, tx)
			if err != nil {
				return rSyncAll(), err
			}
		}
	}

	replaceStr := strings.Replace(cvrfFileFixed, "\n", ",", -1)
	if saSync == nil || saSync.CvrfFile != replaceStr {
		if saSync == nil {
			saSync = new(models.CveCvrfSync)
		}

		if cvrfFileFixed != "" {
			arr := strings.Split(cvrfFileFixed, "\n")
			for _, v := range arr {
				if strings.HasSuffix(v, ".xml") {
					result, _ = SyncSA(v)
					if strings.Index(result, "successfully") == -1 {
						SLog.Error("===>>>update_fixed.txt failed ,message:" + result)
						break
					}
				}
			}
		}
		saSync.CvrfFile = replaceStr
		saSync.Type = _const.UpdateFixed
		saSync.Updateime = time.Now()
		if strings.Index(result, "successfully") > -1 {
			err = dao.DefaultCvrfSync.CreateSyncOne(saSync, tx)
			if err != nil {
				return rSyncAll(), err
			}
		}
	}
	return result, nil
}

func SyncOsv() (string, error) {
	var tools, platform []byte
	var ok bool
	t := time.Now()
	osvList, err := parserOsv()
	if err != nil {
		return fmt.Sprint("获取数据失败:"), err
	}
	err = DB.Transaction(func(tx *gorm.DB) error {
		for k := range osvList {
			v := osvList[k]
			if len(v.PlatformResult) == 0 && len(v.ToolsResult) == 0 {
				err = dao.DefaultCompatibilityOsv.DeleteOsv(v.OsVersion, tx)
				if err != nil {
					return err
				}
				continue
			}
			tools, err = json.Marshal(v.ToolsResult)
			if err != nil {
				return err
			}
			platform, err = json.Marshal(v.PlatformResult)
			if err != nil {
				return err
			}
			osv := models.OeCompatibilityOsv{
				Architecture:         v.Arch,
				OsVersion:            v.OsVersion,
				OsvName:              v.OsvName,
				Date:                 v.Date,
				OsDownloadLink:       v.OsDownloadLink,
				Type:                 v.Type,
				Details:              v.Details,
				FriendlyLink:         v.FriendlyLink,
				TotalResult:          v.TotalResult,
				CheckSum:             v.CheckSum,
				BaseOpeneulerVersion: v.BaseOpeneulerVersion,
				ToolsResult:          string(tools),
				PlatformResult:       string(platform),
				Updateime:            t,
			}
			if ok, err = dao.DefaultCompatibilityOsv.ExistsOsv(osv.OsVersion, tx); err == nil && ok {
				err = dao.DefaultCompatibilityOsv.UpdateOsv(osv, tx)
				if err != nil {
					return err
				}
			} else if err == nil {
				err = dao.DefaultCompatibilityOsv.CreateOsv(osv, tx)
				if err != nil {
					return err
				}
			} else {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	return "success", nil
}

func parserOsv() ([]cvesa.Osv, error) {
	bytes, err := utils.HTTPGet(_const.ParserOsvJsonFile)
	if err != nil {
		return nil, err
	}

	var data []cvesa.Osv

	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil, err
	}
	return data, nil
}
