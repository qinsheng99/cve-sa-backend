package web

import (
	"os"
	"strings"

	"cve-sa-backend/dao"
	"cve-sa-backend/models"
	"cve-sa-backend/utils"
	_const "cve-sa-backend/utils/const"
	"cve-sa-backend/utils/entity/cve_sa"
)

func FindAllCVEDatabase(req cvesa.RequestData) (*cvesa.ResultData, error) {
	datas, total, err := dao.DefaultCveDatabase.DatabaseFindAll(req)
	if err != nil {
		return nil, err
	}
	return ReturnCVEDatabase(datas, total), nil
}

func ReturnCVEDatabase(data []models.CveDatabase, total int64) *cvesa.ResultData {
	cveDatabaseList := make([]cvesa.DatabaseData, 0, len(data))
	for _, v := range data {
		rc := models.RCveDatabase{
			CveDatabase: v,
			Updateime:   v.Updateime.Format(_const.Format),
			CreateTime:  v.CreateTime.Format(_const.Format),
		}
		cveDatabaseList = append(cveDatabaseList, cvesa.DatabaseData{
			RCveDatabase: rc,
		})
	}

	return &cvesa.ResultData{
		SecurityNoticeList:  make([]cvesa.SecurityNoticeData, 0),
		CveDatabaseList:     cveDatabaseList,
		ApplicationCompList: make([]models.ROeCompatibilityApplication, 0),
		HardwareCompList:    make([]cvesa.HardwareCompatibility, 0),
		DriverCompList:      make([]models.OeCompatibilityDriver, 0),
		Total:               int(total),
	}
}

func GetByCveIdAndPackageName(cveId, packageName string, flag bool) (*cvesa.DatabaseData, error) {
	result := &cvesa.DatabaseData{}
	cveData := models.CveDatabase{CveId: cveId}
	if flag {
		cveData.PackageName = packageName
	}
	cve, err := dao.DefaultCveDatabase.GetOneDatabaseTypeTwo(&cveData)
	if utils.ErrorNotFound(err) {
		return nil, nil
	}

	if err != nil {
		return nil, err
	}

	result.RCveDatabase = models.RCveDatabase{
		CveDatabase: *cve,
		Updateime:   cve.Updateime.Format(_const.Format),
		CreateTime:  cve.CreateTime.Format(_const.Format),
	}

	list, err := dao.DefaultSecurityNotice.NoticeByCveIdAndAffectedComponent(cve.CveId, cve.PackageName)
	if err != nil {
		return nil, err
	}

	if len(list) > 0 {
		result.SecurityNoticeNo = list[0].SecurityNoticeNo
	}

	return result, nil
}

func GetCVEProductPackageListByCveId(cveId string) ([]models.RCveProductPackage, error) {
	var result []models.RCveProductPackage
	list, _, err := dao.DefaultCveProductPackage.GetProductPackageListTypeTwo(&models.CveProductPackage{
		CveId: cveId,
	})

	if err != nil {
		return result, err
	}

	for k := range list {
		v := list[k]
		if strings.EqualFold(v.Status, "UnFixed") {
			v.ReleaseTime = ""
			v.SecurityNoticeNo = ""
		}
		result = append(result, models.RCveProductPackage{
			CveProductPackage: v,
			Updateime:         v.Updateime.Format(_const.Format),
		})
	}

	return result, nil

}

func GetCVEProductPackageList(cveId, packageName string) ([]models.RCveProductPackage, error) {
	var result []models.RCveProductPackage
	list, _, err := dao.DefaultCveProductPackage.GetProductPackageListTypeTwo(&models.CveProductPackage{
		CveId:       cveId,
		PackageName: packageName,
	})

	if err != nil {
		return result, err
	}

	for k := range list {
		v := list[k]
		if strings.EqualFold(v.Status, "UnFixed") {
			v.ReleaseTime = ""
			v.SecurityNoticeNo = ""
		}
		result = append(result, models.RCveProductPackage{
			CveProductPackage: v,
			Updateime:         v.Updateime.Format(_const.Format),
		})
	}

	return result, nil
}

func HotpatchList(cveId string) ([]models.CveSecurityHotPatch, error) {
	l, err := dao.DefaultSecurityHotPatch.HotPatchList(&models.CveSecurityHotPatch{CveNum: cveId})
	if err != nil {
		return nil, err
	}

	return l, nil
}

func GetUnfixedCve(file string) ([]string, error) {
	cve, _, err := dao.DefaultCveProductPackage.GetProductPackageListTypeTwo(&models.CveProductPackage{Status: "Unfixed"})
	if err != nil {
		return nil, err
	}

	var result = make([]string, 0, len(cve))

	for _, v := range cve {
		result = append(result, v.CveId+"/"+v.PackageName+"/"+v.ProductName+"/"+v.SecurityNoticeNo)
	}

	os.Remove(file)
	s := strings.Join(result, "\n")
	err = os.WriteFile(file, []byte(s), 0777)
	if err != nil {
		return nil, err
	}

	return result, nil
}
