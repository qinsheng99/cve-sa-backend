package utils

import (
	"encoding/xml"
	"strings"
)

var Severity = map[string]string{
	"critical": "Critical",
	"high":     "Important",
	"medium":   "Moderate",
	"low":      "Low",
}

type (
	cvrfdoc struct {
		Xmlns         string          `xml:"xmlns,attr"`
		Cvrf          string          `xml:"cvrf,attr"`
		Vulnerability []Vulnerability `xml:"Vulnerability"`
	}

	FixedCveXml struct {
		Xmlns              string             `xml:"xmlns,attr"`
		Cvrf               string             `xml:"cvrf,attr"`
		Text               string             `xml:",innerxml"`
		DocumentTitle      DocumentTitle      `xml:"DocumentTitle,omitempty"`
		DocumentType       string             `xml:"DocumentType,omitempty"`
		DocumentPublisher  DocumentPublisher  `xml:"DocumentPublisher,omitempty"`
		DocumentTracking   DocumentTracking   `xml:"DocumentTracking,omitempty"`
		DocumentNotes      DocumentNotes      `xml:"DocumentNotes,omitempty"`
		DocumentReferences DocumentReferences `xml:"DocumentReferences,omitempty"`
		ProductTree        ProductTree        `xml:"ProductTree,omitempty"`
		Vulnerability      []Vulnerability    `xml:"Vulnerability"`
	}

	DocumentTitle struct {
		XmlLang       string `xml:"lang,attr"`
		DocumentTitle string `xml:",innerxml"`
	}

	Vulnerability struct {
		Text            string      `xml:",innerxml"`
		Ordinal         string      `xml:"Ordinal,attr"`
		Xmlns           string      `xml:"xmlns,attr"`
		Notes           Note        `xml:"Notes"`
		ReleaseDate     string      `xml:"ReleaseDate,omitempty"`
		Cve             string      `xml:"CVE"`
		ProductStatuses Status      `xml:"ProductStatuses"`
		Threats         *Threat     `xml:"Threats,omitempty"`
		CVSSScoreSets   ScoreSet    `xml:"CVSSScoreSets"`
		Remediations    Remediation `xml:"Remediations"`
	}

	Note struct {
		Note []Notes
	}

	Status struct {
		Status []ProductID `xml:"Status"`
	}

	ProductID struct {
		Type      string   `xml:"Type,attr"`
		ProductID []string `xml:"ProductID"`
	}

	ScoreSet struct {
		ScoreSet []ScoreSetChild `xml:"ScoreSet"`
	}

	ScoreSetChild struct {
		BaseScore string `xml:"BaseScore"`
		Vector    string `xml:"Vector"`
	}

	Remediation struct {
		Remediation []RemediationChild `xml:"Remediation"`
	}

	RemediationChild struct {
		Type        string `xml:"Type,attr"`
		Description string `xml:"Description"`
		DATE        string `xml:"DATE"`
		ProductID   string `xml:"ProductID,omitempty"`
		URL         string `xml:"URL,omitempty"`
	}

	DocumentPublisher struct {
		Type             string `xml:"Type,attr"`
		ContactDetails   string `xml:"ContactDetails"`
		IssuingAuthority string `xml:"IssuingAuthority"`
	}

	DocumentTracking struct {
		Identification     IdentificationChild `xml:"Identification"`
		Status             string              `xml:"Status"`
		Version            string              `xml:"Version"`
		RevisionHistory    Revision            `xml:"RevisionHistory"`
		InitialReleaseDate string              `xml:"InitialReleaseDate"`
		CurrentReleaseDate string              `xml:"CurrentReleaseDate"`
		Generator          GeneratorChild      `xml:"Generator"`
	}

	Revision struct {
		Revision []RevisionChild `xml:"Revision"`
	}

	RevisionChild struct {
		Number      string `xml:"Number"`
		Date        string `xml:"Date"`
		Description string `xml:"Description"`
	}

	GeneratorChild struct {
		Engine string `xml:"Engine"`
		Date   string `xml:"Date"`
	}

	IdentificationChild struct {
		ID string `xml:"ID"`
	}

	DocumentNotes struct {
		Note []Notes
	}
	Notes struct {
		Title   string `xml:"Title,attr"`
		Type    string `xml:"Type,attr"`
		Ordinal string `xml:"Ordinal,attr"`
		XmlLang string `xml:"lang,attr"`
		Note    string `xml:",innerxml"`
	}

	DocumentReferences struct {
		Reference []ReferenceChild `xml:"Reference"`
	}

	ReferenceChild struct {
		Type string   `xml:"Type,attr"`
		URL  []string `xml:"URL"`
	}

	ProductTree struct {
		Branch []BranchChild `xml:"Branch"`
	}

	BranchChild struct {
		Type            string                 `xml:"Type,attr"`
		Name            string                 `xml:"Name,attr"`
		FullProductName []FullProductNameChild `xml:"FullProductName"`
	}
	FullProductNameChild struct {
		ProductID   string `xml:"ProductID,attr"`
		CPE         string `xml:"CPE,attr"`
		ProductName string `xml:",innerxml"`
	}

	Threat struct {
		Threat []ThreatChild `xml:"Threat"`
	}

	ThreatChild struct {
		Type        string `xml:"Type,attr"`
		Description string `xml:"Description"`
	}

	Updates struct {
		XMLName xml.Name `xml:"updates,omitempty"`
		Updatex []Update `xml:"update,omitempty"`
	}

	Update struct {
		XMLName     xml.Name    `xml:"update,omitempty"`
		From        string      `xml:"from,attr"`
		Type        string      `xml:"type,attr"`
		Status      string      `xml:"status,attr"`
		Id          string      `xml:"id"`
		Title       string      `xml:"title"`
		Severity    string      `xml:"severity"`
		Release     string      `xml:"release"`
		Issued      *Issued     `xml:"issued,omitempty"`
		References  *References `xml:"references,omitempty"`
		Description string      `xml:"description"`
		Pkglist     *Pkglist    `xml:"pkglist,omitempty"`
	}

	Issued struct {
		XMLName xml.Name `xml:"issued,omitempty"`
		Date    string   `xml:"date,attr"`
	}

	References struct {
		XMLName   xml.Name    `xml:"references,omitempty"`
		Reference []Reference `xml:"reference,omitempty"`
	}

	Reference struct {
		XMLName xml.Name `xml:"reference,omitempty"`
		Href    string   `xml:"href,attr"`
		Id      string   `xml:"id,attr"`
		Title   string   `xml:"title,attr"`
		Type    string   `xml:"type,attr"`
	}

	Pkglist struct {
		XMLName    xml.Name    `xml:"pkglist,omitempty"`
		Collection *Collection `xml:"collection,omitempty"`
	}

	Collection struct {
		XMLName xml.Name  `xml:"collection,omitempty"`
		Name    string    `xml:"name"`
		Package []Package `xml:"package,omitempty"`
	}

	Package struct {
		XMLName  xml.Name `xml:"package,omitempty"`
		Epoch    string   `xml:"epoch,attr,omitempty"`
		Arch     string   `xml:"arch,attr"`
		Name     string   `xml:"name,attr"`
		Release  string   `xml:"release,attr"`
		Version  string   `xml:"version,attr"`
		Filename string   `xml:"filename"`
	}
)

func (f FixedCveXml) UnaffectdData(v []Vulnerability) ([]byte, error) {
	var unaffected = cvrfdoc{
		Xmlns:         f.Xmlns,
		Cvrf:          f.Cvrf,
		Vulnerability: v,
	}

	bys, mErr := xml.MarshalIndent(unaffected, "", "   ")
	if mErr != nil {
		return nil, mErr
	}

	headerBytes := []byte(xml.Header)
	headerBytes = append(headerBytes, bys...)

	return headerBytes, nil
}

func (u Updates) NumberIndex(securityNumber string) (index int) {
	index = -1
	for k, v := range u.Updatex {
		if strings.EqualFold(v.Id, securityNumber) {
			index = k
			return
		}
	}

	return
}

func (u Updates) UpdatesData() ([]byte, error) {
	bys, err := xml.MarshalIndent(u, "", "     ")
	if err != nil {
		return nil, err
	}

	headerBytes := []byte(xml.Header)
	headerBytes = append(headerBytes, bys...)

	return headerBytes, nil
}
